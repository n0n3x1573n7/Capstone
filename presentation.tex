% !TeX document-id = {4fba684d-7122-40d6-bb19-80adba5d32d5}
%!TeX TXS-program:compile = txs:///xelatex/
\documentclass{beamer}
\usetheme{Darmstadt}

\newif\ifproposal
\proposalfalse

\usepackage{CJKutf8}

\usepackage[utf8]{inputenc}
\usepackage[OT1, T2A]{fontenc}
\usepackage{fontspec}
\setmainfont[ItalicFont={*},ItalicFeatures={FakeSlant=.167}]{D2Coding}

\usepackage[normalem]{ulem}

\usepackage{graphicx}

\usepackage{braket}
\newcommand{\iu}{{i\mkern1mu}}

% based on the original definitions in beamerbasenavigation.sty
\makeatletter
\def\sectionentry#1#2#3#4#5{% section number, section title, page
	%
	\newcount\mymin%
	\mymin=3
	\ifnum\c@section=1%
	\mymin=5
	\fi%
	\ifnum\c@section=2%
	\mymin=4
	\fi%
	%
	\newcount\mymax%
	\mymax=3
	\ifnum\c@section=\beamer@sectionmax%
	\mymax=5
	\fi%
	\ifnum\c@section=\numexpr\beamer@sectionmax-1%
	\mymax=4
	\fi%
	%
	\ifnum\numexpr\c@section-#1<\mymax%
	\ifnum\numexpr#1-\c@section<\mymin%
	\ifnum#5=\c@part%
	\beamer@section@set@min@width
	\box\beamer@sectionbox\hskip1.875ex plus 1fill%
	\beamer@xpos=0\relax%
	\beamer@ypos=1\relax%
	\setbox\beamer@sectionbox=
	\hbox{
		\def\insertsectionhead{#2}%
		\def\insertsectionheadnumber{#1}%
		\def\insertpartheadnumber{#5}%
		
		{%
			\usebeamerfont{section in head/foot}\usebeamercolor[fg]{section in head/foot}%
			\ifnum\c@section=#1%
			\hyperlink{Navigation#3}{{\usebeamertemplate{section in head/foot}}}%
			\else%
			\hyperlink{Navigation#3}{{\usebeamertemplate{section in head/foot shaded}}}%
			\fi%    
		}%
	}%
	\ht\beamer@sectionbox=1.875ex%
	\dp\beamer@sectionbox=0.75ex%
	\fi%
	\fi%
	\fi%
	\ignorespaces%
}

\def\slideentry#1#2#3#4#5#6{%
	%section number, subsection number, slide number, first/last frame, page number, part number
	%
	\newcount\mymin%
	\mymin=3
	\ifnum\c@section=1%
	\mymin=5
	\fi%
	\ifnum\c@section=2%
	\mymin=4
	\fi%
	%
	\newcount\mymax%
	\mymax=3
	\ifnum\c@section=\beamer@sectionmax%
	\mymax=5
	\fi%
	\ifnum\c@section=\numexpr\beamer@sectionmax-1%
	\mymax=4
	\fi%
	%
	\ifnum\numexpr\c@section-#1<\mymax%
	\ifnum\numexpr#1-\c@section<\mymin%
	\ifnum#6=\c@part\ifnum#2>0\ifnum#3>0%
	\ifbeamer@compress%
	\advance\beamer@xpos by1\relax%
	\else%
	\beamer@xpos=#3\relax%
	\beamer@ypos=#2\relax%
	\fi%
	\hbox to 0pt{%
		\beamer@tempdim=-\beamer@vboxoffset%
		\advance\beamer@tempdim by-\beamer@boxsize%
		\multiply\beamer@tempdim by\beamer@ypos%
		\advance\beamer@tempdim by -.05cm%
		\raise\beamer@tempdim\hbox{%
			\beamer@tempdim=\beamer@boxsize%
			\multiply\beamer@tempdim by\beamer@xpos%
			\advance\beamer@tempdim by -\beamer@boxsize%
			\advance\beamer@tempdim by 1pt%
			\kern\beamer@tempdim
			\global\beamer@section@min@dim\beamer@tempdim
			\hbox{\beamer@link(#4){%
					\usebeamerfont{mini frame}%
					\ifnum\c@section=#1%
					\ifnum\c@subsection=#2%
					\usebeamercolor[fg]{mini frame}%
					\ifnum\c@subsectionslide=#3%
					\usebeamertemplate{mini frame}%\beamer@minislidehilight%
					\else%
					\usebeamertemplate{mini frame in current subsection}%\beamer@minisliderowhilight%
					\fi%
					\else%
					\usebeamercolor{mini frame}%
					%\color{fg!50!bg}%
					\usebeamertemplate{mini frame in other subsection}%\beamer@minislide%
					\fi%
					\else%
					\usebeamercolor{mini frame}%
					%\color{fg!50!bg}%
					\usebeamertemplate{mini frame in other subsection}%\beamer@minislide%
					\fi%
		}}}\hskip-10cm plus 1fil%
	}\fi\fi%
	\else%
	\fakeslideentry{#1}{#2}{#3}{#4}{#5}{#6}%
	\fi%
	\fi%
	\fi%
	\ignorespaces%
}
\makeatother

\AtBeginSection[]{
	\begin{frame}
		\vfill
		\centering
		\begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
			\usebeamerfont{title}\insertsectionhead\par%
		\end{beamercolorbox}
		\vfill
	\end{frame}
}

\usepackage{xcolor}
\usepackage{pgfplots}
\usepackage{tikz}

% Define bar chart colors
%
\definecolor{bblue}{HTML}{4F81BD}
\definecolor{rred}{HTML}{C0504D}
\definecolor{ggreen}{HTML}{9BBB59}
\definecolor{ppurple}{HTML}{9F4C7C}


\title{Quantum Speedup on Exhaustive-search Attacks on Cryptosystems}
\subtitle{Week 7 Report for Class 75}

\author{2017320009 Sangheon Lee\\ 2017320023 Mingyu Cho}

\date{\today}

\begin{document}
	\begin{frame}
		\titlepage
	\end{frame}
	
	\begin{frame}
		\frametitle{Table of Contents}
		\tableofcontents
	\end{frame}
	
	\ifproposal
	\section{Necessity}
	
	\begin{frame}
		\frametitle{Necessity}
		
		\begin{itemize}
			\item ``Quantum Supremacy" imminent
			\item Post-quantum stage makes most cryptosystems used nowadays unsafe
			\begin{itemize}
				\item Prime factorization broken by Shor's Algorithm
			\end{itemize}
		\end{itemize}
	\end{frame}
	
	\section{Content}
	
	\begin{frame}
		\frametitle{Content}
		
		\begin{itemize}
			\item Targeting symmetric-key cryptosystem
			\begin{itemize}
				\item Specifically, DES will be used.
				\item If possible, make it able to be modified for any symmetric-key cryptosystems.
			\end{itemize}
			\item Brute-force exhaustive key search quantum algorithm
		\end{itemize}
	\end{frame}
	
	\section{Methods}
	
	\begin{frame}
		\frametitle{Methods}
		\begin{itemize}
			\item Modify Grover's Algorithm to crack DES
			\begin{itemize}
				\item $\Omega(\sqrt{n})$ search algorithm for a data table of $n$
			\end{itemize}
			\item Optionally, simulate it using projectq, a python-based quantum simulator
			\item Computationally determine and verify expected run-time, compare with existing attacks.
			\item Speed up if possible and/or necessary
		\end{itemize}
	\end{frame}
	
	\section{Expectations}
	
	\begin{frame}
		\frametitle{Expectations}
		
		\begin{itemize}
			\item The quantum algorithm will prove to be faster than at least the traditional brute-force exhaustive search.
			\item Planning to contrast two methods using the length of the key as a fixed variable if the algorithm is modifiable to others.
		\end{itemize}
	\end{frame}
	
	\section{Requirements}
	
	\begin{frame}
		\frametitle{Requirements}
		
		\begin{itemize}
			\item Papers and/or textbooks on quantum computation
			\item Help from Prof. Hong(He suggested the topic)
			\item[]
			\item Currently working with Sangheon Lee to study the backgrounds
			\item Agreed to study together before parting ways
		\end{itemize}
	\end{frame}
	\fi
	
	\section{Backgrounds}
	
	\begin{frame}
		\frametitle{Mathematical Backgrounds}
		\begin{itemize}
			\item Complex numbers
			\begin{itemize}
				\item Complex plane $a+b\iu=(a,b)$
				\item Complex polar $\rho e^{\phi \iu}=\rho \cos \phi + \rho \sin \phi \iu$
			\end{itemize}
			\item 2-dimensional Hilbert space
			\begin{itemize}
				\item A complex vector space, utilizing conjugate transposes.
				\item When constricted to $\mathbb{R}$, same as $\mathbb{R}^2$ vector space.
			\end{itemize}
			\item Most of the time on Week 4 was spent on understanding the mathematical backgrounds on 2-dimensional Hilbert spaces and special matrices which can only be considered on $\mathbb{C}$.
			\item Additionally, analyzing Grover's Algorithm implementation in Microsoft Q\# was done.
		\end{itemize}
	\end{frame}
	
	\section{Qubits}
	\begin{frame}
		\frametitle{Qubits}
		\begin{itemize}
			\item Quantum Bit(Qubit for short) is a probabilistic vector of information.
			\item $\ket{0}=\begin{pmatrix} 1 \\ 0 \end{pmatrix}$, $\ket{1}=\begin{pmatrix} 0 \\ 1 \end{pmatrix}$
			\item A general qubit is represented as $u=\alpha \ket{0}+\beta \ket{1}$
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Three Main Types of Operation}
		\begin{itemize}
			\item Creation
			\item Reversible Operation
			\item Measurement
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Creation}
		\begin{itemize}
			\item As simple as creating $\ket{0}$ or $\ket{1}$.
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Reversible Operation}
		\begin{itemize}
			\item Represented using unitary matrix
			\begin{itemize}
				\item $U^*U=UU^*=I$, where $U^*$ is a conjugate transpose of $U$
			\end{itemize}
			\item Two frequently used operations
			\begin{itemize}
				\item X-gate $X=\begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix}$ (so-called NOT gate)
				\item Hadamard Gate $H=\dfrac{1}{\sqrt{2}}\begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix}$
				\item Hadamard Gate creates a Quantum Superposition
			\end{itemize}
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Measurement}
		\begin{itemize}
			\item A non-deterministic(probabilistic) measure of a qubit $u$.
			\item For a vector $u=\begin{pmatrix} \alpha \\ \beta \end{pmatrix}$ where $\|u\|=1$
			\begin{itemize}
				\item returns "true" with probability $\|\alpha\|^2$, and $u$ becomes $\ket{0}$
				\item returns "false" with probability $\|\beta\|^2$, and $u$ becomes $\ket{1}$
			\end{itemize}
			\item Destroys quantum superposition; often called "destructive".
		\end{itemize}
	\end{frame}
	
	\section{Grover's Algorithm}
	
	\begin{frame}{Overview}
		\begin{itemize}
			\item Grover's algorithm can find a specific state satisfying some condition among $ N = 2^n$ candidates in $ O(\sqrt{N}) $ time, compared to classical runtime complexity $ O(N) $.
			\item Grover's algorithm exploits qualities of quantum amplitudes to gain advantage of probability seperation.
			\item It can brute-force 128-bit symmetric cryptographic key in roughly $ 2^{64} $ iterations.
		\end{itemize}
	\end{frame}
	
	\begin{frame}{Algorithm}
		Input:
		\begin{itemize}
			\item A quantum oracle $ \mathcal{O} $ which performs the operation $ \mathcal{O} \ket{x}  = (-1)^{f(x)} \ket{x}$, where $ f(x) = 0 $ for all $0 \leq x < 2^n $ except $ x_0 $, for which $ f(x_0) = 1 $.
			\begin{itemize}
				\item Such quantum oracle is viable, and takes $ O(1) $ time.
			\end{itemize}
			\item $ n $ qubits initialized to the state $ \ket{0} $
		\end{itemize}
		Output: $ x_0 $, in runtime $ O(\sqrt{2^n}) $ with error rate $ O(\frac{1}{2^n}) $
	\end{frame}
	
	\begin{frame}{Algorithm}
		Procedure:
		\begin{enumerate}
			\item $ \ket{0}^{\otimes n} $ (initial state)
			\item $ H^{\otimes n} \ket{0}^{\otimes n} = \dfrac{1}{\sqrt{2^n}} \sum\limits_{x=0}^{2^n-1}\ket{x} = \ket{\psi}$ (Hadamard transform)
			\item $ [(2 \ket{\psi} \bra{\psi} - I) \mathcal{O}]^R \ket{\psi} \approx \ket{x_0}  $ (Grover iteration for $ R \approx  \frac{\pi}{4}\sqrt{2^n} $ times)
			\item $ x_0 $ (measure)
		\end{enumerate}
		Grover iteration in a nutshell: negate the amplitude of the desired state, followed by `diffusion transform' which increases the amplitude of the desired state and lower the others.
	\end{frame}
	
	\section{Quantum S-DES Oracle}
	
	\begin{frame}{S-DES}
		\begin{itemize}
			\item Simplified DES with 2 rounds
			\item Structure similar to DES but simplified with 10-bit key and 8-bit plaintext.
			\item Quantum oracle needs to be reversible, of which S-DES is (normally) not.
		\end{itemize}
	\end{frame}
	
	\begin{frame}{Structure of S-DES}
		\begin{figure}[h]
			\centering
			\includegraphics[width=0.5\textwidth]{./Images/sdes.png}
		\end{figure}
	\end{frame}
	
	\begin{frame}{Quantumizing S-DES}
		\begin{itemize}
			\item Most parts are permutations or compressions; no problems here.
			\item Two parts poses a challenge:
		\end{itemize}
		\begin{enumerate}
			\item S-Boxes
			\begin{itemize}
				\item Consists of lookup table: not ideal for our situation.
				\item \sout{Broken the S-Boxes into fundamental and/or/not-gates}
				\item Actually, the brute-force method(of checking each cases) enables reusage of ancilla bits, thereby reducing the number of required qubits!
				\item Classic gates are not reversible; use CNOT/CCNOT gates to make them reversible.
				
			\end{itemize}
			\item Expansion
			\begin{itemize}
				\item Due to \href{https://en.wikipedia.org/wiki/No-cloning_theorem}{No-cloning theorem}, directly copying a qubit is not possible.
				\item Use XOR operation to copy the information.
			\end{itemize}
		\end{enumerate}
	\end{frame}
    
    \section{Quantum S-DES Implementation}
    
   	\begin{frame}{S-DES Obstacles}
   		\begin{itemize}
            \item Expansion : Directly clone with XOR twice
            \begin{itemize}
                \item With extra 8 qubits, we can explicitly use expanded plaintext
            \end{itemize}
            \item S-Box : Passing all the candidates
            \begin{itemize}
                \item Denote S-Box function as $ f : \{0,1\}^4 \to \{0,1\}^2 $
                \item If the dealing plaintext has a basis for $ x \in \{0, 1\}^4 $, apply XOR(NOT) to result S-Box qubit
            \end{itemize}
   		\end{itemize}
   	\end{frame}  
       
   	\begin{frame}{Quantum S-DES Implementation}
        Initially, 34 explicit qubits were used in total.
   		\begin{itemize}
            \item 10 qubits for input key
            \item 1 qubit for making an encryption oracle
            \item 8 qubits for (intermediate) plaintext
            \item 8 qubits for expanded plaintext
            \item 4 qubits for storing S-Box result
            \item 3 qubit for S-Box ancilla
   		\end{itemize}
        S-DES implementation is written in Microsoft Q\#. Will it run?
   	\end{frame}
       
   	\begin{frame}{Quantum S-DES Implementation}
        Yes, and no.
   		\begin{figure}[h]
            \centering
            \includegraphics[height=0.5\textheight]{./Images/Qsharp-SDES-memory-error-2.png}
        \end{figure}
        After allocating 48GB of RAM, \texttt{System.Runtime.InteropServices.SEHException} was raised, indicating an out-of-memory error.
   	\end{frame}
       
   	\begin{frame}{Quantum S-DES Implementation}
        Reducing the number of qubits was necessary...!
        \begin{itemize}
            \item 10 qubits for input key
            \item 1 qubit for making an encryption oracle
            \item 8 qubits for (intermediate) plaintext
            \item \only<1>{8 qubits for expanded plaintext} \only<2->{{\color{gray}\sout{8 qubits for expanded plaintext}}}
            \item \only<1-2>{4}\only<3>{{\color{gray}\sout{4}} 2} qubits for storing S-Box result
            \item 3 qubit for S-Box ancilla
        \end{itemize}
   		\onslide<2-> We can directly use plaintext qubits to create result qubits from S-Box. After then we can undo all the operations (permutation, \textit{etc.}) which altered plaintext.
           
        \onslide<3>Additionally, each S-Box operation is independent. Thus we can reuse S-box result qubits after re-initialization.
   	\end{frame} 
       
       
   	\begin{frame}{Quantum S-DES Implementation}
        After a bit of debugging and comparing with Python Implementation...
        \only<1>{
            \begin{figure}
                \centering
                \includegraphics[height=0.5\textheight]{./Images/Qsharp-SDES-24-qubits.png}
            \end{figure}
            It ran well within 40s (before the second optimization, it took 4x time and memory)
        }
        \only<2>{
            \begin{figure}
                \centering
                \includegraphics[height=0.5\textheight]{./Images/Qsharp-SDES-res.png}
            \end{figure}
            Expected cipher matched with Python S-DES implementation output.
        }
   	\end{frame} 
       
   	\begin{frame}{Quantum S-DES Implementation}
        However, applying Grover's was not simple as it looked
        \begin{itemize}
            \item The oracle should be adjoint, but current version includes measurement (in result ciphertext and S-Box)
            \item How to create an oracle qubit rather than measuring the result ciphertext?
            \begin{itemize}
                \item perform CNOT gate 8 times (with 7 more qubits) : infeasible
                \item \texttt{Controlled} functor : doable
                \item All-one oracle : similar (which is faster?)
            \end{itemize}
        \end{itemize}
        
   	\end{frame}
       
   	\begin{frame}{Quantum S-DES Implementation}
        \begin{itemize}
            \item Measurement was wiped out smoothly with the cost of execution speed
            \item Each round need to be reversed, and so does the S-Box, increased runtime about 4x
            \item Qubit optimization in S-Box offset this demerit
            \begin{itemize}
                \item Used the same `all-one oracle' trick
            \end{itemize}
        \end{itemize}
   	\end{frame}
       
   	\begin{frame}{Quantum S-DES Implementation}
        \begin{figure}
            \centering
            \includegraphics[height=0.5\textheight]{./Images/Qsharp-SDES-Grover-k1.png}
        \end{figure}
        Expected key matched with original key (with runtime 19 min 31 sec, performing each S-DES encryption within 45s on average).
   	\end{frame}
       
    \section{Quantum S-DES Testing}
       
    \begin{frame}{Prerequisites}
        \begin{itemize}
            \item Let $ SDES(P, K) = C $ be a function s.t. encrypting plaintext $ P $ with S-DES and key $ K $ yields $ C $.
            \item Let $ f : \{0, 1\}^8 \times \{0, 1\}^8 \to \mathcal{P}({\{0, 1\}^{10}})$ be a function such that $ f(P, C) = \{ K \in \{0, 1\}^{10} \,\vert\, SDES(P, K) = C\}$.
            \item Since key size is 4x of cipher size, we guessed that for arbitrary $ P $ and $ C $, $ \left\vert f(P, C) \right\vert$ is likely to be 4.
        \end{itemize}
    \end{frame}
    
    \begin{frame}{Prerequisites : Key Size}
        ...and we were wrong!
        % include graph here
        \begin{tikzpicture}
            \begin{axis}[
                width  = 0.95*\textwidth,
                height = 0.8\textheight,
%                major x tick style = transparent,
                ybar,
                bar width=6pt,
                ymajorgrids = true,
                ylabel = {\# of $ (P, C) $ pairs},
                xlabel = {Key size},
                symbolic x coords={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17},
                xtick = data,
                enlarge x limits=0.05,
                ymin=0,
                ymode=log,
            ]
   
                \addplot[style={bblue,fill=bblue,mark=none}]
                    coordinates {
                        (1, 4376)
                        (2, 10696)
                        (3, 6888)
                        (4, 11896)
                        (5, 3848)
                        (6, 9576)
                        (7, 2728)
                        (8, 4184)
                        (9, 968)
                        (10, 1944)
                        (11, 272)
                        (12, 456)
                        (13, 16)
                        (14, 24)
                        (15, 96)
                        (16, 8)
                        (17, 8)
                        };
            \end{axis}
        \end{tikzpicture}
    \end{frame}
       
   	\begin{frame}{Quantum S-DES Testing : Testing with \#Key = 1}
        If $ (P, C) =$ (\texttt{10100100}, \texttt{00110011}). Then $ f(P, C) = $  $\{$\texttt{1101100110}$\}$.
        \begin{itemize}
            \item Program yielded correct key.
            \item By dumping key qubits, we can observe the probability of each basis.
            \begin{itemize}
                \item At first, the probability of answer basis is $ 0.008766 $ while the others are $ 0.000969 $.
                \item The gap widens next turn: $ 0.024224 $ and $ 0.000954 $.
                \item Ultimately it becomes $ 0.999461 $ and $ 0.000001 $ (at 25th iteration).
            \end{itemize}
        \end{itemize}
   	\end{frame} 
       
       
   	\begin{frame}{Quantum S-DES Testing : Testing with \#Key = 4}
        If $ (P, C) =$ (\texttt{11000111}, \texttt{00010100}). Then $ \vert f(P, C) \vert = 4$.
        \begin{itemize}
            \item Program yielded wrong key.
            \item By dumping key qubits, we can observe the probability of each basis.
            \begin{itemize}
                \item At first, the probability of answer basis is $ 0.008698 $ while the others are $ 0.000946 $.
                \item The gap widens next turn: $ 0.023659 $ and $ 0.000888 $.
                \item It peaks at 12th iteration: $ 0.249987 $ and $ 0.000000 $.
                \item However it goes back next turn: $ 0.246547 $ and $ 0.000014 $
                \item Ultimately the probability of answer basis becomes lower than the others: $ 0.000575 $ and $ 0.000978 $.
            \end{itemize}
            \item Although the algorithm and the implementation is correct, what happened here? % 논문 추가
        \end{itemize}
   	\end{frame}
     
    
	\section{Current Works and Future Plans}
	
	\begin{frame}
		\frametitle{Work in Progress(Mingyu Cho)}
		\begin{itemize}
			\item Implemented a non-quantum S-DES(in python) for testing the quantum version.
			\item Implemented Brute-force attack on S-DES and developed a code for keycount for (plaintext, ciphertext) pair.
			\item Started preliminary analysis on the gate applications
			\item Looking for possible speedups on the quantum side to aid the simulation
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Work in Progress(Sangheon Lee)}
		\begin{itemize}
            \item Possibly reduce some quantum gates
            \item Analyze complexity of each gate
            \item Search for internal dumping library
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Future Plans}
		\begin{itemize}
			%\item Dig in deeper on the backgrounds, if necessary.
			%\item Understand Grover's Algorithm and other quantum algorithms to know how to utilize it.
			%\item Update sample code of Grover's Algorithm by implementing oracle function and randomization.
			%\item Possibly utilize IBM Quantum Experience?
			%\item Search some more sample codes (not sure if implementing and debugging Shor's and QFT is necessary).
			\item Construct and test S-DES and apply Grover's.
            \begin{itemize}
                \item Since S-DES consists of various components, all of these must be implemented carefully and in order
            \end{itemize}
            \item Hope to import Microsoft Q\# implementation to qiskit (IBM Quantum Experience)
            \item Reduce complexity of quantum gates if possible (as Prof. Hong suggested)
		\end{itemize}
	\end{frame}
\end{document}